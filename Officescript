function main(workbook: ExcelScript.Workbook) {
  const generalSheet = workbook.getWorksheet("General Info");
  const financialSheet = workbook.getWorksheet("Financial");
  const productCapabilities = workbook.getWorksheet("Product Capabilities");

  if (!generalSheet || !financialSheet || !productCapabilities) {
    console.log("One or more required sheets are missing!");
    return;
  }

  let finalSheet = workbook.getWorksheet("Final Data");
  if (!finalSheet) {
    finalSheet = workbook.addWorksheet("Final Data");
  } else {
    finalSheet.getUsedRange()?.clear();
  }

  const generalHeadersMap: { ExcelLabel: string; FinalSheetDataHeader: string; propertyName?: string }[] = [
    { ExcelLabel: "Claims Contact:", FinalSheetDataHeader: "Partner Claim Contact Email", propertyName: "Email" },
    { ExcelLabel: "Claims Contact:", FinalSheetDataHeader: "Partner Claim Contact Name", propertyName: "Name" },
    { ExcelLabel: "Insurer:", FinalSheetDataHeader: "Partner Name" },
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Email", propertyName: "Email" },
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Name", propertyName: "Name" },
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Phone", propertyName: "Phone" },
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Title", propertyName: "Title" }
  ];

  const financialHeadersMap: { ExcelLabel: string; FinalSheetDataHeader: string }[] = [
    { ExcelLabel: "Payment Period:", FinalSheetDataHeader: "Payment Period" }
  ];

  const productCapabilitiesHeadersMap: { ExcelLabel: string; FinalSheetDataHeader: string }[] = [
    { ExcelLabel: "Requirements Notes", FinalSheetDataHeader: "Partner Notes" }
  ];

  const allHeaders = [...generalHeadersMap, ...financialHeadersMap, ...productCapabilitiesHeadersMap].map(obj => obj.FinalSheetDataHeader);
  finalSheet.getRangeByIndexes(0, 0, 1, allHeaders.length).setValues([allHeaders]);

  const generalData = generalSheet.getUsedRange()?.getValues() || [];
  const financialData = financialSheet.getUsedRange()?.getValues() || [];
  const productCapabilitiesData = productCapabilities.getUsedRange()?.getValues() || [];

  const generalExtractedData = generalHeadersMap.map(obj =>
    extractStructuredValueFromMatrix(generalData, obj.ExcelLabel, obj.propertyName)
  );
  const financialExtractedData = financialHeadersMap.map(obj =>
    extractStructuredValueFromMatrix(financialData, obj.ExcelLabel)
  );
  const productCapabilitiesExtractedData = productCapabilitiesHeadersMap.map(obj =>
    extractStructuredValueFromMatrix(productCapabilitiesData, obj.ExcelLabel)
  );

  const rowData = [...generalExtractedData, ...financialExtractedData, ...productCapabilitiesExtractedData];
  finalSheet.getRangeByIndexes(1, 0, 1, rowData.length).setValues([rowData]);

  console.log("Final Data sheet updated with flexible parsing.");
}

// Extract value from matrix and parse it if structured
function extractStructuredValueFromMatrix(
  matrix: (string | number | boolean)[][],
  label: string,
  propertyName?: string
): string {
  const normalizedLabel = normalize(label);

  for (const row of matrix) {
    const key = normalize((row[0] ?? '').toString());

    if (key.includes(normalizedLabel) || normalizedLabel.includes(key)) {
      for (let j = 1; j < row.length; j++) {
        const raw = (row[j] ?? '').toString().trim();
        if (raw !== '') {
          if (propertyName) {
            return extractStructuredProperty(raw, propertyName);
          }
          return raw;
        }
      }
    }
  }

  return '';
}

// Normalize strings for comparison
function normalize(text: string): string {
  return text.toLowerCase().replace(/\s+/g, ' ').trim();
}

// Generic structured multiline parser
function extractStructuredProperty(rawText: string, property: string): string {
  const entries = rawText.split(/\n\s*\n/); // separate by blank lines
  const results: string[] = [];

  for (const entry of entries) {
    const lines = entry.split(/\r?\n/);
    const props: { [key: string]: string } = {};

    for (const line of lines) {
      const match = line.match(/^([^:]+):\s*(.+)$/);
      if (match) {
        const key = normalize(match[1]);
        const value = match[2].trim();
        props[key] = value;
      }
    }

    const requestedValue = props[normalize(property)];
    if (requestedValue) {
      results.push(requestedValue);
    }
  }

  return results.join(', ');
}

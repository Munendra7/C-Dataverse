function main(workbook: ExcelScript.Workbook) {
  const sheets = {
    general: workbook.getWorksheet("General Info"),
    financial: workbook.getWorksheet("Financial"),
    product: workbook.getWorksheet("Product Capabilities")
  };

  if (!sheets.general || !sheets.financial || !sheets.product) {
    console.log("One or more required sheets are missing!");
    return;
  }

  let finalSheet = workbook.getWorksheet("Final Data");
  if (!finalSheet) {
    finalSheet = workbook.addWorksheet("Final Data");
  } else {
    finalSheet.getUsedRange()?.clear();
  }

  const generalHeadersMap = [
    { ExcelLabel: "Local Broker Required?", FinalSheetDataHeader: "Broker Requirement" },
    { ExcelLabel: "Insurer:", FinalSheetDataHeader: "Local Insurer Name" },
    { ExcelLabel: "Country", FinalSheetDataHeader: "Local Reinsurer Country" },
    { ExcelLabel: "Local Reinsurer Address", FinalSheetDataHeader: "Local Reinsurer Address" },
    { ExcelLabel: "Local Reinsurer Name", FinalSheetDataHeader: "Local Reinsurer Name" },
    { ExcelLabel: "Local Reinsurer Notes", FinalSheetDataHeader: "Local Reinsurer Notes" },
    { ExcelLabel: "Local Reinsurer Retention Percent", FinalSheetDataHeader: "Local Reinsurer Retention %" },
    { ExcelLabel: "Is a Local Reinsurer used? (If No, disregard the below questions)", FinalSheetDataHeader: "Local Reinsurer?" },
    { ExcelLabel: "Local Insurer Abbreviated Name:", FinalSheetDataHeader: "Partner Abbreviated Name" },
    { ExcelLabel: "Address:", FinalSheetDataHeader: "Partner Address" },

    // Contact Fields - each in separate columns
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Name", property: "name" },
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Title", property: "title" },
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Email", property: "email" },
    { ExcelLabel: "Primary Contact:", FinalSheetDataHeader: "Partner Primary Contact Phone", property: "phone" },
    
    { ExcelLabel: "Claims Contact:", FinalSheetDataHeader: "Partner Claim Contact Name", property: "name" },
    { ExcelLabel: "Claims Contact:", FinalSheetDataHeader: "Partner Claim Contact Title", property: "title" },
    { ExcelLabel: "Claims Contact:", FinalSheetDataHeader: "Partner Claim Contact Email", property: "email" },
    { ExcelLabel: "Claims Contact:", FinalSheetDataHeader: "Partner Claim Contact Phone", property: "phone" }
  ];

  const financialHeadersMap = [
    { ExcelLabel: "Payment conditions:", FinalSheetDataHeader: "Cash Before Cover?" },
    { ExcelLabel: "Permitted Collection Type(s)", FinalSheetDataHeader: "Collection Types - Permitted" },
    { ExcelLabel: "Preferred Collection Type", FinalSheetDataHeader: "Preferred Collection Types" },
    { ExcelLabel: "Currencies Available", FinalSheetDataHeader: "Available Policy Currency" },
    { ExcelLabel: "Currencies Available", FinalSheetDataHeader: "Standard Policy Currency" },
    { ExcelLabel: "Local Insurer Retention Percent (minimum required)", FinalSheetDataHeader: "Insurer Retention Percentage" },
    { ExcelLabel: "Payment Notes (add any payment or collection information that is unique to your company or country):", FinalSheetDataHeader: "Payment Notes" },
    { ExcelLabel: "Payment Period:", FinalSheetDataHeader: "Payment Period" },
    { ExcelLabel: "Payment conditions:", FinalSheetDataHeader: "Payment Type" }
  ];

  const productCapabilitiesHeadersMap = [
    { ExcelLabel: "Can you issue manuscript wording?", FinalSheetDataHeader: "Manuscripting allowed?" },
    { ExcelLabel: "Requirements Notes", FinalSheetDataHeader: "Partner Notes" },
    { ExcelLabel: "What, if any, conditions are there when backdating?", FinalSheetDataHeader: "Policy - Backdating Conditions" },
    { ExcelLabel: "Policy Language?", FinalSheetDataHeader: "Policy - Language" },
    { ExcelLabel: "Minimum Policy Period", FinalSheetDataHeader: "Policy Term - < 1 year allowed?" },
    { ExcelLabel: "Maximum Policy Period", FinalSheetDataHeader: "Policy Term - Maximum" },
    { ExcelLabel: "Policy Wording used?", FinalSheetDataHeader: "Policy Wording - Good Local Standard Available?" },
    { ExcelLabel: "Local Policy Wording Notes", FinalSheetDataHeader: "Policy Wording Notes" },
    { ExcelLabel: "Requirements (Subjectivities)*", FinalSheetDataHeader: "Subjectivities" },
    { ExcelLabel: "Tie-In of Limits Allowed?", FinalSheetDataHeader: "Tie-in of Limits Permitted?" }
  ];

  const allMappings = [...generalHeadersMap, ...financialHeadersMap, ...productCapabilitiesHeadersMap];
  const allHeaders = allMappings.map(m => m.FinalSheetDataHeader);

  // Set headers
  finalSheet.getRangeByIndexes(0, 0, 1, allHeaders.length).setValues([allHeaders]);

  // Pull raw data
  const sheetData = {
    general: sheets.general.getUsedRange()?.getValues() ?? [],
    financial: sheets.financial.getUsedRange()?.getValues() ?? [],
    product: sheets.product.getUsedRange()?.getValues() ?? []
  };

  const rowData: string[] = allMappings.map(mapping => {
    const source = mapping.ExcelLabel;
    const prop = mapping.property;
    let data: (string | number | boolean)[][] = [];

    if (sheetData.general.some(row => (row[0] ?? '').toString().includes(source))) {
      data = sheetData.general;
    } else if (sheetData.financial.some(row => (row[0] ?? '').toString().includes(source))) {
      data = sheetData.financial;
    } else if (sheetData.product.some(row => (row[0] ?? '').toString().includes(source))) {
      data = sheetData.product;
    }

    if (prop) {
      return extractContactProperty(data, source, prop);
    } else {
      return findSingleCellValue(data, source);
    }
  });

  finalSheet.getRangeByIndexes(1, 0, 1, rowData.length).setValues([rowData]);
  console.log("Final Data sheet populated successfully.");
}

// Extracts a simple label:value mapping
function findSingleCellValue(data: (string | number | boolean)[][], label: string): string {
  const normalized = label.toLowerCase().trim();
  for (const row of data) {
    const cellLabel = (row[0] ?? '').toString().toLowerCase().trim();
    if (cellLabel.includes(normalized)) {
      return row[1]?.toString().trim() ?? "";
    }
  }
  return "";
}

// Extracts contact property from multiline tabular fields
function extractContactProperty(data: (string | number | boolean)[][], label: string, property: string): string {
  const propertyIndexMap: { [key: string]: number } = {
    name: 0,
    title: 1,
    email: 2,
    phone: 3
  };

  for (const row of data) {
    const cell = (row[0] ?? '').toString().toLowerCase();
    if (cell.includes(label.toLowerCase())) {
      const parts = row.slice(1).map(val => val?.toString().trim() ?? "");
      return parts[propertyIndexMap[property]] ?? "";
    }
  }
  return "";
}

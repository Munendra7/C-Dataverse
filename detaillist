import JSZip from "jszip";
import { saveAs } from "file-saver";

export type SelectedItem = {
  Type: "File" | "Folder";
  name: string;
  Url: string; // For files: server-relative file URL; For folders: relative path (e.g. "Folder/Sub")
};

/** Toast/progress callbacks */
export type DownloadCallbacks = {
  onStart?: (summary: string, detail?: string) => void;    // sticky loader start
  onProgress?: (summary: string, detail?: string) => void; // loader text updates
  onClear?: () => void;                                    // clear/hide loader
  onSuccess?: (summary: string, detail?: string) => void;  // success toast
  onWarn?: (summary: string, detail?: string) => void;     // warning toast
  onError?: (summary: string, detail?: string) => void;    // error toast
};

export type DownloadOptions = {
  sp: any;
  siteRelativeUrl: string;
  documentLibrary: string;
  selected: SelectedItem[];
  // Cap per ZIP part (default 500MB)
  maxZipSizeBytes?: number;
  // Optional max number of parts to avoid excessive files (default: unlimited)
  maxParts?: number;
  // Guard to ensure one download at a time
  inProgressRef?: { current: boolean };
  // Toast/progress callbacks
  callbacks?: DownloadCallbacks;
};

export async function downloadItemsMultiZip(options: DownloadOptions): Promise<void> {
  const {
    sp,
    siteRelativeUrl,
    documentLibrary,
    selected,
    maxZipSizeBytes = 500 * 1024 * 1024, // 500MB
    maxParts,
    inProgressRef,
    callbacks,
  } = options;

  const start = (s: string, d?: string) => callbacks?.onStart?.(s, d);
  const progress = (s: string, d?: string) => callbacks?.onProgress?.(s, d);
  const clear = () => callbacks?.onClear?.();
  const success = (s: string, d?: string) => callbacks?.onSuccess?.(s, d);
  const warn = (s: string, d?: string) => callbacks?.onWarn?.(s, d);
  const error = (s: string, d?: string) => callbacks?.onError?.(s, d);

  if (!selected || selected.length === 0) {
    warn?.("No items selected", "Please select at least one file or folder.");
    return;
  }

  if (inProgressRef?.current) {
    warn?.("Another download is in progress", "Please wait for it to finish.");
    return;
  }

  try {
    if (inProgressRef) inProgressRef.current = true;

    // Fast path: single file -> native download (best perf)
    if (selected.length === 1 && selected[0].Type === "File") {
      clear?.();
      const file = selected[0];
      const encodedUrl = `${siteRelativeUrl}/_layouts/download.aspx?sourceUrl=${encodeURIComponent(file.Url)}`;
      window.location.href = encodedUrl;
      success?.("Download started", file.name);
      return;
    }

    start?.("Preparing download...", "Fetching items…");

    // Build flat list of files to download (zip entries), with sizes
    const zipEntries: Array<{ zipPath: string; serverRelativeUrl: string; size: number }> = [];

    // Add FILEs (preserve folder structure)
    for (const item of selected) {
      if (item.Type === "File") {
        const size = await getFileSizeRLDAS(sp, documentLibrary, item.Url);
        // Get relative path from document library root
        const relPath = item.Url.split(`/${documentLibrary}/`)[1] || item.name;
        zipEntries.push({ zipPath: relPath, serverRelativeUrl: item.Url, size });
      }
    }

    // Add FOLDERs (expand via RLDAS, threshold-safe)
    for (const item of selected) {
      if (item.Type === "Folder") {
        await addFolderFilesRLDAS(sp, siteRelativeUrl, documentLibrary, item.Url, item.name, zipEntries);
      }
    }

    if (zipEntries.length === 0) {
      clear?.();
      warn?.("Nothing to download", "No files were found in the selection.");
      return;
    }

    // If any single file > cap, warn and download that file natively (splitting can't help)
    const overCapSingles = zipEntries.filter(e => e.size > maxZipSizeBytes);
    if (overCapSingles.length > 0) {
      clear?.();
      const big = overCapSingles[0];
      warn?.(
        "A file exceeds the ZIP part size",
        `“${big.zipPath}” is ${(big.size / (1024 * 1024)).toFixed(0)} MB, larger than the part cap. Downloading it directly.`
      );
      const encodedUrl = `${siteRelativeUrl}/_layouts/download.aspx?sourceUrl=${encodeURIComponent(big.serverRelativeUrl)}`;
      window.location.href = encodedUrl;
      const remaining = zipEntries.filter(e => e !== big);
      if (remaining.length === 0) {
        success?.("Download started", big.zipPath);
        return;
      }
      start?.("Preparing remaining items...", "Large file sent to native download.");
      await multiZipAndSave(remaining, maxZipSizeBytes, maxParts, progress, warn, () => {}, selected); // Don't clear loader until all done
      clear?.();
      success?.("Downloads ready", "One native + multi-part ZIP(s) saved.");
      return;
    }

    // All good -> multi-zip
    await multiZipAndSave(zipEntries, maxZipSizeBytes, maxParts, progress, warn, () => {}, selected); // Don't clear loader until all done
    clear?.();
    success?.("Downloads ready", "Your ZIP parts have been saved.");
  } catch (e: any) {
    console.error("downloadItemsMultiZip error:", e);
    clear?.();
    error?.("Failed to download", e?.message || "Please try fewer items or try again.");
  } finally {
    if (inProgressRef) inProgressRef.current = false;
  }
}

async function multiZipAndSave(
  entries: Array<{ zipPath: string; serverRelativeUrl: string; size: number }>,
  maxZipSizeBytes: number,
  maxParts: number | undefined,
  progress: (s: string, d?: string) => void,
  warn: (s: string, d?: string) => void,
  clear: () => void,
  selected: SelectedItem[]
) {
  let part = 1;
  let bytesInPart = 0;
  let filesInPart = 0;
  let totalProcessed = 0;
  const totalFiles = entries.length;

  let zip = new JSZip();
  const failedFiles: string[] = [];

  // Helper to finalize and save the current part
  const finalizePart = async () => {
    let lastPct = 0;
    progress(`Zipping Part ${part}…`, `0%`);
    const blob = await zip.generateAsync(
      { type: "blob" },
      (meta) => {
        const pct = Math.floor(meta.percent);
        if (pct !== lastPct && pct % 10 === 0) {
          progress(`Zipping Part ${part}…`, `${pct}%`);
          lastPct = pct;
        }
      }
    );
    saveAs(blob, suggestedZipPartName(selected, part));
  };

  // Concurrency pool for downloads
  const CONCURRENCY = 10;
  let i = 0;
  while (i < entries.length) {
    const batch = entries.slice(i, i + CONCURRENCY);
    // Download all files in the batch concurrently
    await Promise.all(batch.map(async (entry) => {
      // Need a new part?
      if (filesInPart > 0 && (bytesInPart + entry.size) > maxZipSizeBytes) {
        await finalizePart();
        part++;
        if (maxParts && part > maxParts) {
          throw new Error(`Reached max parts (${maxParts}). Please reduce selection or increase limit.`);
        }
        zip = new JSZip();
        bytesInPart = 0;
        filesInPart = 0;
      }
      // Fetch blob and add to zip
      const encodedServerRelativeUrl = encodeURI(entry.serverRelativeUrl);
      try {
        const blob = await getBlobWithRetryGlobal(encodedServerRelativeUrl);
        zip.file(entry.zipPath, blob);
        bytesInPart += entry.size || blob.size || 0;
        filesInPart++;
      } catch (err) {
        console.error(`Failed to fetch file: ${entry.zipPath}`, err);
        failedFiles.push(entry.zipPath);
      }
      totalProcessed++;
      progress("Downloading files…", `${totalProcessed} / ${totalFiles}`);
    }));
    // Only after all in batch are done, move to next batch
    i += CONCURRENCY;
  }

  // Save final part (if it has any files)
  if (filesInPart > 0) {
    await finalizePart();
  }
 
  //Uncomment to enable warning on failed files
  // if (failedFiles.length > 0) {
  //   warn(
  //       "Some files could not be downloaded",
  //       `Failed files count: ${failedFiles.length}`
  //     );
  // }
}

function suggestedZipPartName(selected: SelectedItem[], part: number): string {
  const base = suggestedBaseName(selected);
  return `${base}_Part${part}.zip`;
}

function suggestedBaseName(selected: SelectedItem[]): string {
  if (selected.length === 1) {
    return selected[0].name.replace(/\.zip$/i, "") || "Documents";
  }
  const first = selected[0]?.name || "Documents";
  return `${sanitizeFileName(first)}_and_${selected.length - 1}_more`;
}

function sanitizeFileName(name: string) {
  return name.replace(/[\\/:*?"<>|]/g, "_");
}

let __spForRetry: any = null;
export function setSpForRetry(sp: any) { __spForRetry = sp; }

async function spCallWithRetry<T>(fn: () => Promise<T>, context: string, maxRetries = 5): Promise<T> {
  let attempt = 0;
  while (true) {
    try {
      return await fn();
    } catch (err: any) {
      const status = err?.status || err?.data?.status || err?.httpStatus || 0;
      const isThrottle = status === 429 || status === 503 || status === 406;
      if (!isThrottle || attempt >= maxRetries) throw err;

      const jitter = Math.floor(Math.random() * 250);
      const backoff = Math.max(2 ** attempt * 10000, 10000) + jitter;

      console.warn(`[Retry ${attempt + 1}/${maxRetries}] ${context} due to ${status}. Waiting ${backoff}ms`);
      await new Promise((r) => setTimeout(r, backoff));
      attempt++;
    }
  }
}

// bind sp for blob fetches (so we don't thread it through deep)
async function getBlobWithRetryGlobal(serverRelativeUrl: string): Promise<Blob> {
  if (!__spForRetry) throw new Error("Internal: SP context not set");
  return spCallWithRetry(
    () => __spForRetry.web.getFileByServerRelativeUrl(serverRelativeUrl).getBlob(),
    `getBlob ${serverRelativeUrl}`
  );
}

function renderListDataWithRetry(sp: any, documentLibrary: string, args: any) {
  return spCallWithRetry(
    () => sp.web.lists.getByTitle(documentLibrary).renderListDataAsStream(args),
    "renderListDataAsStream"
  );
}

// Get a file's size via RLDAS (threshold-safe)
async function getFileSizeRLDAS(sp: any, documentLibrary: string, fileRef: string): Promise<number> {
  const folderPath = fileRef.split("/").slice(0, -1).join("/");
  const ViewXml = `
    <View>
      <ViewFields>
        <FieldRef Name='FileRef'/>
        <FieldRef Name='File_x0020_Size'/>
      </ViewFields>
      <Query>
        <Where>
          <Eq>
            <FieldRef Name='FileRef'/>
            <Value Type='Text'>${fileRef}</Value>
          </Eq>
        </Where>
      </Query>
      <RowLimit>1</RowLimit>
    </View>
  `;
  const resp = await renderListDataWithRetry(sp, documentLibrary, {
    FolderServerRelativeUrl: folderPath,
    ViewXml,
    RenderOptions: 2,
  }) as { Row?: any[] };
  const r = resp?.Row?.[0];
  return Number(r?.["File_x0020_Size"] ?? 0);
}

// Expand a folder to files via RLDAS (Scope="RecursiveAll"), push into zipEntries
async function addFolderFilesRLDAS(
  sp: any,
  siteRelativeUrl: string,
  documentLibrary: string,
  folderUrl: string,          // relative (e.g., "Folder/Sub") or server-relative
  topLevelFolderName: string,
  zipEntries: Array<{ zipPath: string; serverRelativeUrl: string; size: number }>
) {
  const serverRelativeFolder = folderUrl.startsWith(siteRelativeUrl)
    ? folderUrl
    : `${siteRelativeUrl}/${documentLibrary}/${folderUrl}`;

  const ViewXml = `
    <View Scope="RecursiveAll">
      <ViewFields>
        <FieldRef Name='FileLeafRef'/>
        <FieldRef Name='FileDirRef'/>
        <FieldRef Name='FileRef'/>
        <FieldRef Name='FSObjType'/>
        <FieldRef Name='File_x0020_Size'/>
      </ViewFields>
      <Query>
        <Where>
            <Eq>
                <FieldRef Name='FSObjType'/>
                <Value Type='Integer'>0</Value>
            </Eq>
        </Where>
      </Query>
      <RowLimit Paged='TRUE'>2000</RowLimit>
    </View>
  `;

  let next: string | null = null;
  while (true) {
    const paging = next ? next.replace("?", "") : null;
    const resp = await renderListDataWithRetry(sp, documentLibrary, {
      FolderServerRelativeUrl: serverRelativeFolder,
      ViewXml,
      Paging: paging,
      RenderOptions: 2,
    }) as { Row?: any[]; NextHref?: string };

    for (const r of resp?.Row ?? []) {
      if ((r.FSObjType ?? "0").toString() !== "0") continue;
      const fileRef: string = r.FileRef;
      const size = Number(r["File_x0020_Size"] ?? 0);
      const relFromFolder = fileRef.replace(serverRelativeFolder + "/", "");
      const zipPath = `${topLevelFolderName}/${relFromFolder}`;
      zipEntries.push({ zipPath, serverRelativeUrl: fileRef, size });
    }

    next = resp?.NextHref || null;
    if (!next) break;
  }
}

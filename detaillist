import * as React from "react";
import { sp } from "@pnp/sp/presets/all";
import JSZip from "jszip";
import { saveAs } from "file-saver";

// Constants for optimization
const MAX_ZIP_SIZE = 500 * 1024 * 1024; // 500MB per zip
const MAX_FILES_PER_ZIP = 1000; // Limit files per zip
const BATCH_SIZE = 50; // Process files in batches to avoid memory issues
const LIST_THRESHOLD_BATCH = 4000; // Stay under 5000 item threshold

interface DownloadProgress {
  totalFiles: number;
  processedFiles: number;
  currentZip: number;
  totalZips: number;
  status: string;
}

// Optimized download function with chunking and progress tracking
export const downloadFilesOptimized = async (
  selection: any,
  setSelectedItems: any,
  loaderToastBottomCenter: any,
  toastBottomCenter: any,
  showToastMessage: any,
  hideToastMessage: any,
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string
) => {
  try {
    showToastMessage(
      "Preparing download...",
      "Analyzing files and folders...",
      loaderToastBottomCenter,
      "info",
      true
    );

    const selectedItems: any = selection.getSelection();

    // Single file download - direct download without zip
    if (selectedItems.length === 1 && selectedItems[0].Type === "File") {
      await downloadFileDirect(selectedItems[0], toastBottomCenter, showToastMessage);
      selection.setAllSelected(false);
      setSelectedItems([]);
      hideToastMessage(loaderToastBottomCenter);
      return;
    }

    // Collect all files from selected items
    const allFiles = await collectAllFiles(
      selectedItems,
      siteRelativeUrl,
      DOCUMENT_LIBRARY,
      loaderToastBottomCenter,
      showToastMessage
    );

    if (allFiles.length === 0) {
      showToastMessage("No files to download", "The selected items contain no files.", toastBottomCenter, "warning");
      hideToastMessage(loaderToastBottomCenter);
      return;
    }

    // Split files into multiple zips if necessary
    const zipGroups = splitIntoZipGroups(allFiles);

    showToastMessage(
      "Downloading files...",
      `Preparing ${zipGroups.length} zip file(s) with ${allFiles.length} total files...`,
      loaderToastBottomCenter,
      "info",
      true
    );

    // Download each zip group
    for (let i = 0; i < zipGroups.length; i++) {
      await createAndDownloadZip(
        zipGroups[i],
        i,
        zipGroups.length,
        allFiles.length,
        loaderToastBottomCenter,
        toastBottomCenter,
        showToastMessage,
        siteRelativeUrl
      );
    }

    hideToastMessage(loaderToastBottomCenter);
    showToastMessage(
      "Download completed!",
      `Successfully downloaded ${allFiles.length} file(s) in ${zipGroups.length} zip(s)`,
      toastBottomCenter,
      "success"
    );

    selection.setAllSelected(false);
    setSelectedItems([]);
  } catch (error) {
    console.error("Error downloading files:", error);
    hideToastMessage(loaderToastBottomCenter);
    showToastMessage(
      "Download failed",
      error.message || "An error occurred during download",
      toastBottomCenter,
      "error"
    );
  }
};

// Direct file download without creating zip
const downloadFileDirect = async (file: any, toastBottomCenter: any, showToastMessage: any) => {
  try {
    const fileBlob = await sp.web.getFileByServerRelativeUrl(file.Url).getBlob();
    const link = document.createElement("a");
    link.href = URL.createObjectURL(fileBlob);
    link.download = file.name;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up blob URL to free memory
    setTimeout(() => URL.revokeObjectURL(link.href), 100);
    
    showToastMessage("Download started", `Downloading ${file.name}...`, toastBottomCenter, "success");
  } catch (error) {
    console.error(`Failed to download ${file.name}:`, error);
    showToastMessage(`Failed to download ${file.name}`, "", toastBottomCenter, "error");
    throw error;
  }
};

// Collect all files from selected items (handles folders recursively with batching)
const collectAllFiles = async (
  selectedItems: any[],
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string,
  loaderToastBottomCenter: any,
  showToastMessage: any
): Promise<any[]> => {
  const allFiles: any[] = [];
  const processed = new Set<string>();

  for (const item of selectedItems) {
    if (item.Type === "File") {
      if (!processed.has(item.Url)) {
        allFiles.push({
          url: item.Url,
          name: item.name,
          path: ""
        });
        processed.add(item.Url);
      }
    } else {
      showToastMessage(
        "Scanning folder...",
        `Scanning ${item.name}...`,
        loaderToastBottomCenter,
        "info",
        true
      );
      const folderFiles = await collectFolderFilesOptimized(
        item.Url,
        item.name,
        siteRelativeUrl,
        DOCUMENT_LIBRARY,
        processed
      );
      allFiles.push(...folderFiles);
    }
  }

  return allFiles;
};

// Optimized folder file collection using batched queries to avoid list threshold
const collectFolderFilesOptimized = async (
  folderUrl: string,
  folderName: string,
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string,
  processed: Set<string>,
  basePath: string = ""
): Promise<any[]> => {
  const files: any[] = [];
  const currentPath = basePath ? `${basePath}/${folderName}` : folderName;

  try {
    const folderRelativeUrl = folderUrl.includes(siteRelativeUrl)
      ? folderUrl
      : `${siteRelativeUrl}/${DOCUMENT_LIBRARY}/${folderUrl}`;

    // Use batched CAML query to get items efficiently
    let position: string | null = null;
    let hasMore = true;

    while (hasMore) {
      const ViewXml = `
        <View Scope="RecursiveAll">
          <ViewFields>
            <FieldRef Name='FileLeafRef'/>
            <FieldRef Name='FileRef'/>
            <FieldRef Name='FSObjType'/>
            <FieldRef Name='FileDirRef'/>
          </ViewFields>
          <Query>
            <Where>
              <Eq>
                <FieldRef Name='FSObjType' />
                <Value Type='Integer'>0</Value>
              </Eq>
            </Where>
          </Query>
          <RowLimit Paged='TRUE'>${LIST_THRESHOLD_BATCH}</RowLimit>
        </View>
      `;

      const result = await sp.web.lists
        .getByTitle(DOCUMENT_LIBRARY)
        .renderListDataAsStream({
          FolderServerRelativeUrl: folderRelativeUrl,
          ViewXml: ViewXml,
          Paging: position,
          RenderOptions: 2
        });

      // Process files from this batch
      for (const item of result.Row) {
        if (item.FSObjType === "0" && !processed.has(item.FileRef)) {
          // Calculate relative path within the zip
          const itemPath = item.FileDirRef.replace(folderRelativeUrl, "").replace(/^\//, "");
          const fullPath = itemPath ? `${currentPath}/${itemPath}` : currentPath;

          files.push({
            url: item.FileRef,
            name: item.FileLeafRef,
            path: fullPath
          });
          processed.add(item.FileRef);
        }
      }

      // Check if there are more items
      position = result.NextHref || null;
      hasMore = !!position;

      // Small delay to avoid throttling
      if (hasMore) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  } catch (error) {
    console.error(`Error collecting files from folder ${folderName}:`, error);
    throw error;
  }

  return files;
};

// Split files into groups based on size and count limits
const splitIntoZipGroups = (files: any[]): any[][] => {
  const groups: any[][] = [];
  let currentGroup: any[] = [];
  let currentSize = 0;

  for (const file of files) {
    // Estimate file size (we'll check actual size during download)
    // Add to current group if under limits
    if (currentGroup.length >= MAX_FILES_PER_ZIP || currentSize >= MAX_ZIP_SIZE * 0.8) {
      if (currentGroup.length > 0) {
        groups.push(currentGroup);
      }
      currentGroup = [];
      currentSize = 0;
    }

    currentGroup.push(file);
  }

  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }

  return groups.length > 0 ? groups : [files];
};

// Create and download a zip file with progress tracking
const createAndDownloadZip = async (
  files: any[],
  zipIndex: number,
  totalZips: number,
  totalFiles: number,
  loaderToastBottomCenter: any,
  toastBottomCenter: any,
  showToastMessage: any,
  siteRelativeUrl: string
) => {
  const zip = new JSZip();
  let processedCount = 0;

  try {
    // Process files in batches to avoid memory issues
    for (let i = 0; i < files.length; i += BATCH_SIZE) {
      const batch = files.slice(i, i + BATCH_SIZE);

      showToastMessage(
        `Creating zip ${zipIndex + 1}/${totalZips}...`,
        `Processing files ${processedCount + 1}-${Math.min(processedCount + batch.length, files.length)} of ${files.length}...`,
        loaderToastBottomCenter,
        "info",
        true
      );

      // Download files in parallel within batch
      const batchPromises = batch.map(async (file) => {
        try {
          const fileBlob = await sp.web.getFileByServerRelativeUrl(file.url).getBlob();
          const filePath = file.path ? `${file.path}/${file.name}` : file.name;
          zip.file(filePath, fileBlob);
        } catch (error) {
          console.error(`Failed to add ${file.name} to zip:`, error);
          // Continue with other files even if one fails
        }
      });

      await Promise.all(batchPromises);
      processedCount += batch.length;

      // Small delay between batches to prevent throttling
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    // Generate and download zip
    showToastMessage(
      `Generating zip ${zipIndex + 1}/${totalZips}...`,
      "Compressing files, please wait...",
      loaderToastBottomCenter,
      "info",
      true
    );

    const zipBlob = await zip.generateAsync(
      { type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } },
      (metadata) => {
        // Progress callback during zip generation
        const percent = metadata.percent.toFixed(0);
        showToastMessage(
          `Generating zip ${zipIndex + 1}/${totalZips}...`,
          `Compression progress: ${percent}%`,
          loaderToastBottomCenter,
          "info",
          true
        );
      }
    );

    const zipFileName = totalZips > 1 ? `Documents_Part${zipIndex + 1}.zip` : "Documents.zip";
    saveAs(zipBlob, zipFileName);

    showToastMessage(
      `Zip ${zipIndex + 1}/${totalZips} ready`,
      `${zipFileName} is downloading...`,
      toastBottomCenter,
      "success"
    );

    // Clear zip from memory
    zip.remove(/.*/);
  } catch (error) {
    console.error(`Error creating zip ${zipIndex + 1}:`, error);
    throw error;
  }
};

// Updated addFolderToZip function (for backward compatibility, but not used in optimized flow)
export const addFolderToZipOptimized = async (
  zip: any,
  folderUrl: any,
  folderName: any,
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string
) => {
  const folderNameUrl = folderUrl.includes(siteRelativeUrl)
    ? folderUrl
    : `${siteRelativeUrl}/${DOCUMENT_LIBRARY}/${folderUrl}`;

  // Use the optimized collection method
  const files = await collectFolderFilesOptimized(
    folderUrl,
    folderName,
    siteRelativeUrl,
    DOCUMENT_LIBRARY,
    new Set<string>()
  );

  // Add files to zip in batches
  for (let i = 0; i < files.length; i += BATCH_SIZE) {
    const batch = files.slice(i, i + BATCH_SIZE);
    const batchPromises = batch.map(async (file) => {
      try {
        const fileBlob = await sp.web.getFileByServerRelativeUrl(file.url).getBlob();
        const filePath = file.path ? `${file.path}/${file.name}` : file.name;
        zip.file(filePath, fileBlob);
      } catch (error) {
        console.error(`Failed to add ${file.name}:`, error);
      }
    });
    await Promise.all(batchPromises);
    
    // Delay between batches
    if (i + BATCH_SIZE < files.length) {
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  }
};

// Example usage in your component:
// Replace your existing downloadFiles function with:
// 
// const downloadFiles = async () => {
//   await downloadFilesOptimized(
//     selection,
//     setSelectedItems,
//     loaderToastBottomCenter,
//     toastBottomCenter,
//     showToastMessage,
//     hideToastMessage,
//     siteRelativeUrl,
//     DOCUMENT_LIBRARY
//   );
// };

// downloadHelper.ts
import JSZip from "jszip";
import { saveAs } from "file-saver";

/** Your selection item shape */
export type SelectedItem = {
  Type: "File" | "Folder";
  name: string;
  Url: string; // For files: server-relative file URL; For folders: relative path (e.g. "Folder/Sub")
};

/** Toast/progress callbacks */
export type DownloadCallbacks = {
  onStart?: (summary: string, detail?: string) => void;    // sticky loader start
  onProgress?: (summary: string, detail?: string) => void; // loader text updates
  onClear?: () => void;                                    // clear/hide loader
  onSuccess?: (summary: string, detail?: string) => void;  // success toast
  onWarn?: (summary: string, detail?: string) => void;     // warning toast
  onError?: (summary: string, detail?: string) => void;    // error toast
};

export type DownloadOptions = {
  sp: any;                         // SPFI or 'sp' from @pnp/sp
  siteRelativeUrl: string;         // "/sites/YourSite"
  documentLibrary: string;         // "Documents"
  selected: SelectedItem[];
  // Cap per ZIP part (default 500MB)
  maxZipSizeBytes?: number;
  // Optional max number of parts to avoid excessive files (default: unlimited)
  maxParts?: number;
  // Guard to ensure one download at a time
  inProgressRef?: { current: boolean };
  // Toast/progress callbacks
  callbacks?: DownloadCallbacks;
};

export async function downloadItemsMultiZip(options: DownloadOptions): Promise<void> {
  const {
    sp,
    siteRelativeUrl,
    documentLibrary,
    selected,
    maxZipSizeBytes = 500 * 1024 * 1024, // 500MB
    maxParts,
    inProgressRef,
    callbacks,
  } = options;

  const start = (s: string, d?: string) => callbacks?.onStart?.(s, d);
  const progress = (s: string, d?: string) => callbacks?.onProgress?.(s, d);
  const clear = () => callbacks?.onClear?.();
  const success = (s: string, d?: string) => callbacks?.onSuccess?.(s, d);
  const warn = (s: string, d?: string) => callbacks?.onWarn?.(s, d);
  const error = (s: string, d?: string) => callbacks?.onError?.(s, d);

  if (!selected || selected.length === 0) {
    warn?.("No items selected", "Please select at least one file or folder.");
    return;
  }

  if (inProgressRef?.current) {
    warn?.("Another download is in progress", "Please wait for it to finish.");
    return;
  }

  try {
    if (inProgressRef) inProgressRef.current = true;

    // Fast path: single file -> native download (best perf)
    if (selected.length === 1 && selected[0].Type === "File") {
      clear?.();
      const file = selected[0];
      window.location.href = `${siteRelativeUrl}/_layouts/download.aspx?sourceUrl=${encodeURIComponent(file.Url)}`;
      success?.("Download started", file.name);
      return;
    }

    start?.("Preparing download...", "Fetching items…");

    // Build flat list of files to download (zip entries), with sizes
    const zipEntries: Array<{ zipPath: string; serverRelativeUrl: string; size: number }> = [];

    // Add FILEs
    for (const item of selected) {
      if (item.Type === "File") {
        const size = await getFileSizeRLDAS(sp, documentLibrary, item.Url);
        zipEntries.push({ zipPath: item.name, serverRelativeUrl: item.Url, size });
      }
    }

    // Add FOLDERs (expand via RLDAS, threshold-safe)
    for (const item of selected) {
      if (item.Type === "Folder") {
        await addFolderFilesRLDAS(sp, siteRelativeUrl, documentLibrary, item.Url, item.name, zipEntries);
      }
    }

    if (zipEntries.length === 0) {
      clear?.();
      warn?.("Nothing to download", "No files were found in the selection.");
      return;
    }

    // If any single file > cap, warn and download that file natively (splitting can't help)
    const overCapSingles = zipEntries.filter(e => e.size > maxZipSizeBytes);
    if (overCapSingles.length > 0) {
      clear?.();
      const big = overCapSingles[0];
      warn?.(
        "A file exceeds the ZIP part size",
        `“${big.zipPath}” is ${(big.size / (1024 * 1024)).toFixed(0)} MB, larger than the part cap. Downloading it directly.`
      );
      window.location.href = `${siteRelativeUrl}/_layouts/download.aspx?sourceUrl=${encodeURIComponent(big.serverRelativeUrl)}`;
      // Continue with remaining items (excluding the huge one)
      const remaining = zipEntries.filter(e => e !== big);
      if (remaining.length === 0) {
        success?.("Download started", big.zipPath);
        return;
      }
      start?.("Preparing remaining items...", "Large file sent to native download.");
      await multiZipAndSave(remaining, maxZipSizeBytes, maxParts, progress, clear, selected);
      success?.("Downloads ready", "One native + multi-part ZIP(s) saved.");
      return;
    }

    // All good -> multi-zip
    await multiZipAndSave(zipEntries, maxZipSizeBytes, maxParts, progress, clear, selected);
    success?.("Downloads ready", "Your ZIP parts have been saved.");
  } catch (e: any) {
    console.error("downloadItemsMultiZip error:", e);
    clear?.();
    error?.("Failed to download", e?.message || "Please try fewer items or try again.");
  } finally {
    if (inProgressRef) inProgressRef.current = false;
  }
}

/* -------------------- internals -------------------- */

async function multiZipAndSave(
  entries: Array<{ zipPath: string; serverRelativeUrl: string; size: number }>,
  maxZipSizeBytes: number,
  maxParts: number | undefined,
  progress: (s: string, d?: string) => void,
  clear: () => void,
  selected: SelectedItem[]
) {
  let part = 1;
  let bytesInPart = 0;
  let filesInPart = 0;
  let totalProcessed = 0;
  const totalFiles = entries.length;

  let zip = new JSZip();

  // Helper to finalize and save the current part
  const finalizePart = async () => {
    let lastPct = 0;
    progress(`Zipping Part ${part}…`, `0%`);
    const blob = await zip.generateAsync(
      { type: "blob" },
      (meta) => {
        const pct = Math.floor(meta.percent);
        if (pct !== lastPct && pct % 10 === 0) {
          progress(`Zipping Part ${part}…`, `${pct}%`);
          lastPct = pct;
        }
      }
    );
    clear();
    saveAs(blob, suggestedZipPartName(selected, part));
  };

  for (const entry of entries) {
    // Need a new part?
    if (filesInPart > 0 && (bytesInPart + entry.size) > maxZipSizeBytes) {
      await finalizePart();

      // Next part
      part++;
      if (maxParts && part > maxParts) {
        throw new Error(`Reached max parts (${maxParts}). Please reduce selection or increase limit.`);
      }
      zip = new JSZip();
      bytesInPart = 0;
      filesInPart = 0;
    }

    // Fetch blob (throttling-safe) and add to zip
    progress("Downloading files…", `${totalProcessed + 1} / ${totalFiles}`);
    const blob = await getBlobWithRetryGlobal(entry.serverRelativeUrl);
    zip.file(entry.zipPath, blob);
    bytesInPart += entry.size || blob.size || 0;
    filesInPart++;
    totalProcessed++;
  }

  // Save final part (if it has any files)
  if (filesInPart > 0) {
    await finalizePart();
  }
}

function suggestedZipPartName(selected: SelectedItem[], part: number): string {
  const base = suggestedBaseName(selected);
  return `${base}_Part${part}.zip`;
}

function suggestedBaseName(selected: SelectedItem[]): string {
  if (selected.length === 1) {
    return selected[0].name.replace(/\.zip$/i, "") || "Documents";
  }
  const first = selected[0]?.name || "Documents";
  return `${sanitizeFileName(first)}_and_${selected.length - 1}_more`;
}

function sanitizeFileName(name: string) {
  return name.replace(/[\\/:*?"<>|]/g, "_");
}

/* -------------------- SharePoint helpers -------------------- */

// Global store for sp + retry; set once per call for simplicity
let __spForRetry: any = null;
export function setSpForRetry(sp: any) { __spForRetry = sp; }

// throttling-safe wrapper
async function spCallWithRetry<T>(fn: () => Promise<T>, context: string, maxRetries = 5): Promise<T> {
  let attempt = 0;
  while (true) {
    try {
      return await fn();
    } catch (err: any) {
      const status = err?.status || err?.data?.status || err?.httpStatus || 0;
      const isThrottle = status === 429 || status === 503;
      if (!isThrottle || attempt >= maxRetries) throw err;

      const retryAfterHeader = err?.response?.headers?.get?.("Retry-After");
      const retryAfterMs = retryAfterHeader ? Number(retryAfterHeader) * 1000 : 0;
      const jitter = Math.floor(Math.random() * 250);
      const backoff = retryAfterMs || Math.min(2 ** attempt * 750, 8000) + jitter;

      console.warn(`[Retry ${attempt + 1}/${maxRetries}] ${context} due to ${status}. Waiting ${backoff}ms`);
      await new Promise((r) => setTimeout(r, backoff));
      attempt++;
    }
  }
}

// bind sp for blob fetches (so we don't thread it through deep)
async function getBlobWithRetryGlobal(serverRelativeUrl: string): Promise<Blob> {
  if (!__spForRetry) throw new Error("Internal: SP context not set");
  return spCallWithRetry(
    () => __spForRetry.web.getFileByServerRelativeUrl(serverRelativeUrl).getBlob(),
    `getBlob ${serverRelativeUrl}`
  );
}

function renderListDataWithRetry(sp: any, documentLibrary: string, args: any) {
  return spCallWithRetry(
    () => sp.web.lists.getByTitle(documentLibrary).renderListDataAsStream(args),
    "renderListDataAsStream"
  );
}

// Get a file's size via RLDAS (threshold-safe)
async function getFileSizeRLDAS(sp: any, documentLibrary: string, fileRef: string): Promise<number> {
  const folderPath = fileRef.split("/").slice(0, -1).join("/");
  const ViewXml = `
    <View>
      <ViewFields>
        <FieldRef Name='FileRef'/>
        <FieldRef Name='File_x0020_Size'/>
      </ViewFields>
      <Query>
        <Where>
          <Eq>
            <FieldRef Name='FileRef'/>
            <Value Type='Text'>${fileRef}</Value>
          </Eq>
        </Where>
      </Query>
      <RowLimit>1</RowLimit>
    </View>
  `;
  const resp = await renderListDataWithRetry(sp, documentLibrary, {
    FolderServerRelativeUrl: folderPath,
    ViewXml,
    RenderOptions: 2,
  });
  const r = resp?.Row?.[0];
  return Number(r?.["File_x0020_Size"] ?? 0);
}

// Expand a folder to files via RLDAS (Scope="RecursiveAll"), push into zipEntries
async function addFolderFilesRLDAS(
  sp: any,
  siteRelativeUrl: string,
  documentLibrary: string,
  folderUrl: string,          // relative (e.g., "Folder/Sub") or server-relative
  topLevelFolderName: string,
  zipEntries: Array<{ zipPath: string; serverRelativeUrl: string; size: number }>
) {
  const serverRelativeFolder = folderUrl.startsWith(siteRelativeUrl)
    ? folderUrl
    : `${siteRelativeUrl}/${documentLibrary}/${folderUrl}`;

  const ViewXml = `
    <View Scope="RecursiveAll">
      <ViewFields>
        <FieldRef Name='FileLeafRef'/>
        <FieldRef Name='FileDirRef'/>
        <FieldRef Name='FileRef'/>
        <FieldRef Name='FSObjType'/>
        <FieldRef Name='File_x0020_Size'/>
      </ViewFields>
      <Query>
        <Where>
          <Eq>
            <FieldRef Name='FSObjType'/>
            <Value Type='Integer'>0</Value>
          </Eq>
        </Where>
      </Query>
      <RowLimit Paged='TRUE'>2000</RowLimit>
    </View>
  `;

  let next: string | null = null;
  while (true) {
    const paging = next ? next.replace("?", "") : null;
    const resp = await renderListDataWithRetry(sp, documentLibrary, {
      FolderServerRelativeUrl: serverRelativeFolder,
      ViewXml,
      Paging: paging,
      RenderOptions: 2,
    });

    for (const r of resp?.Row ?? []) {
      if ((r.FSObjType ?? "0").toString() !== "0") continue;
      const fileRef: string = r.FileRef;
      const size = Number(r["File_x0020_Size"] ?? 0);
      const relFromFolder = fileRef.replace(serverRelativeFolder + "/", "");
      const zipPath = `${topLevelFolderName}/${relFromFolder}`;
      zipEntries.push({ zipPath, serverRelativeUrl: fileRef, size });
    }

    next = resp?.NextHref || null;
    if (!next) break;
  }
}





import { downloadItemsMultiZip, setSpForRetry } from "./downloadHelper"; // adjust path

// inside your component:
const isDownloadingRef = React.useRef<boolean>(false);

// simple wrappers using your existing toasts:
const startLoader = (s: string, d?: string) => showToastMessage(s, d || "", loaderToastBottomCenter, "info", true);
const updateLoader = (s: string, d?: string) => { hideToastMessage(loaderToastBottomCenter); showToastMessage(s, d || "", loaderToastBottomCenter, "info", true); };
const clearLoader = () => hideToastMessage(loaderToastBottomCenter);

// Use this in your existing handler:
const downloadFiles = async () => {
  const selected = selection.getSelection() as any[]; // matches SelectedItem

  // Provide sp once for retry-enabled calls
  setSpForRetry(sp);

  await downloadItemsMultiZip({
    sp,
    siteRelativeUrl,
    documentLibrary: DOCUMENT_LIBRARY,
    selected,
    maxZipSizeBytes: 500 * 1024 * 1024, // 500 MB per part (tweak as needed)
    // maxParts: 10, // optional safety bound
    inProgressRef: isDownloadingRef,
    callbacks: {
      onStart: startLoader,
      onProgress: updateLoader,
      onClear: clearLoader,
      onSuccess: (s, d) => showToastMessage(s, d || "", toastBottomCenter, "success"),
      onWarn: (s, d) => showToastMessage(s, d || "", toastBottomCenter, "warn"),
      onError: (s, d) => showToastMessage(s, d || "", toastBottomCenter, "error"),
    },
  });

  // Optional: clear selection
  selection.setAllSelected(false);
  setSelectedItems([]);
};

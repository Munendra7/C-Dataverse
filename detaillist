import * as React from "react";
import { sp } from "@pnp/sp/presets/all";
import JSZip from "jszip";
import { saveAs } from "file-saver";

// Constants for optimization
const MAX_ZIP_SIZE = 500 * 1024 * 1024; // 500MB per zip
const MAX_FILES_PER_ZIP = 1000; // Limit files per zip
const BATCH_SIZE = 50; // Process files in batches to avoid memory issues
const LIST_THRESHOLD_BATCH = 4000; // Stay under 5000 item threshold

interface DownloadProgress {
  totalFiles: number;
  processedFiles: number;
  currentZip: number;
  totalZips: number;
  status: string;
}

// Global cancel flag
let cancelDownload = false;

export const setCancelDownload = (value: boolean) => {
  cancelDownload = value;
};

// Optimized download function with chunking and progress tracking
export const downloadFilesOptimized = async (
  selection: any,
  setSelectedItems: any,
  loaderToastBottomCenter: any,
  toastBottomCenter: any,
  showToastMessage: any,
  hideToastMessage: any,
  updateToastMessage: any,
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string
) => {
  cancelDownload = false; // Reset cancel flag
  
  try {
    // Show initial toast with cancel button
    showToastMessage(
      "Preparing download...",
      "Analyzing files and folders...",
      loaderToastBottomCenter,
      "info",
      true,
      true // Show cancel button
    );

    const selectedItems: any = selection.getSelection();

    // Single file download - direct download without zip
    if (selectedItems.length === 1 && selectedItems[0].Type === "File") {
      await downloadFileDirect(selectedItems[0], toastBottomCenter, showToastMessage, updateToastMessage, loaderToastBottomCenter);
      selection.setAllSelected(false);
      setSelectedItems([]);
      hideToastMessage(loaderToastBottomCenter);
      return;
    }

    // Collect all files from selected items
    const allFiles = await collectAllFiles(
      selectedItems,
      siteRelativeUrl,
      DOCUMENT_LIBRARY,
      loaderToastBottomCenter,
      updateToastMessage
    );

    if (cancelDownload) {
      hideToastMessage(loaderToastBottomCenter);
      showToastMessage("Download cancelled", "The download was cancelled by user.", toastBottomCenter, "warning");
      selection.setAllSelected(false);
      setSelectedItems([]);
      return;
    }

    if (allFiles.length === 0) {
      hideToastMessage(loaderToastBottomCenter);
      showToastMessage("No files to download", "The selected items contain no files.", toastBottomCenter, "warning");
      return;
    }

    // Split files into multiple zips if necessary
    const zipGroups = splitIntoZipGroups(allFiles);

    updateToastMessage(
      "Downloading files...",
      `Preparing ${zipGroups.length} zip file(s) with ${allFiles.length} total files...`,
      loaderToastBottomCenter
    );

    // Download each zip group
    for (let i = 0; i < zipGroups.length; i++) {
      if (cancelDownload) {
        hideToastMessage(loaderToastBottomCenter);
        showToastMessage("Download cancelled", "The download was cancelled by user.", toastBottomCenter, "warning");
        selection.setAllSelected(false);
        setSelectedItems([]);
        return;
      }

      await createAndDownloadZip(
        zipGroups[i],
        i,
        zipGroups.length,
        allFiles.length,
        loaderToastBottomCenter,
        toastBottomCenter,
        updateToastMessage,
        siteRelativeUrl
      );
    }

    hideToastMessage(loaderToastBottomCenter);
    showToastMessage(
      "Download completed!",
      `Successfully downloaded ${allFiles.length} file(s) in ${zipGroups.length} zip(s)`,
      toastBottomCenter,
      "success"
    );

    selection.setAllSelected(false);
    setSelectedItems([]);
  } catch (error) {
    console.error("Error downloading files:", error);
    hideToastMessage(loaderToastBottomCenter);
    
    if (cancelDownload) {
      showToastMessage("Download cancelled", "The download was cancelled by user.", toastBottomCenter, "warning");
    } else {
      showToastMessage(
        "Download failed",
        error.message || "An error occurred during download",
        toastBottomCenter,
        "error"
      );
    }
  }
};

// Direct file download without creating zip
const downloadFileDirect = async (
  file: any,
  toastBottomCenter: any,
  showToastMessage: any,
  updateToastMessage: any,
  loaderToastBottomCenter: any
) => {
  try {
    updateToastMessage("Downloading file...", `Downloading ${file.name}...`, loaderToastBottomCenter);
    
    const fileBlob = await sp.web.getFileByServerRelativeUrl(file.Url).getBlob();
    
    if (cancelDownload) {
      throw new Error("Download cancelled");
    }
    
    const link = document.createElement("a");
    link.href = URL.createObjectURL(fileBlob);
    link.download = file.name;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up blob URL to free memory
    setTimeout(() => URL.revokeObjectURL(link.href), 100);
    
    showToastMessage("Download started", `Downloading ${file.name}...`, toastBottomCenter, "success");
  } catch (error) {
    console.error(`Failed to download ${file.name}:`, error);
    if (!cancelDownload) {
      showToastMessage(`Failed to download ${file.name}`, "", toastBottomCenter, "error");
    }
    throw error;
  }
};

// Collect all files from selected items (handles folders recursively with batching)
const collectAllFiles = async (
  selectedItems: any[],
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string,
  loaderToastBottomCenter: any,
  updateToastMessage: any
): Promise<any[]> => {
  const allFiles: any[] = [];
  const processed = new Set<string>();

  for (const item of selectedItems) {
    if (cancelDownload) {
      throw new Error("Download cancelled");
    }

    if (item.Type === "File") {
      if (!processed.has(item.Url)) {
        allFiles.push({
          url: item.Url,
          name: item.name,
          path: ""
        });
        processed.add(item.Url);
      }
    } else {
      updateToastMessage(
        "Scanning folder...",
        `Scanning ${item.name}... (${allFiles.length} files found so far)`,
        loaderToastBottomCenter
      );
      
      const folderFiles = await collectFolderFilesOptimized(
        item.Url,
        item.name,
        siteRelativeUrl,
        DOCUMENT_LIBRARY,
        processed,
        "",
        loaderToastBottomCenter,
        updateToastMessage
      );
      allFiles.push(...folderFiles);
    }
  }

  return allFiles;
};

// Optimized folder file collection using batched queries to avoid list threshold
const collectFolderFilesOptimized = async (
  folderUrl: string,
  folderName: string,
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string,
  processed: Set<string>,
  basePath: string = "",
  loaderToastBottomCenter: any = null,
  updateToastMessage: any = null
): Promise<any[]> => {
  const files: any[] = [];
  const currentPath = basePath ? `${basePath}/${folderName}` : folderName;

  try {
    const folderRelativeUrl = folderUrl.includes(siteRelativeUrl)
      ? folderUrl
      : `${siteRelativeUrl}/${DOCUMENT_LIBRARY}/${folderUrl}`;

    // Use batched CAML query to get items efficiently
    let pagingInfo: string | null = null;
    let batchCount = 0;

    while (true) {
      if (cancelDownload) {
        throw new Error("Download cancelled");
      }

      const ViewXml = `
        <View Scope="RecursiveAll">
          <ViewFields>
            <FieldRef Name='FileLeafRef'/>
            <FieldRef Name='FileRef'/>
            <FieldRef Name='FSObjType'/>
            <FieldRef Name='FileDirRef'/>
          </ViewFields>
          <Query>
            <Where>
              <Eq>
                <FieldRef Name='FSObjType' />
                <Value Type='Integer'>0</Value>
              </Eq>
            </Where>
          </Query>
          <RowLimit Paged='TRUE'>${LIST_THRESHOLD_BATCH}</RowLimit>
        </View>
      `;

      const result = await sp.web.lists
        .getByTitle(DOCUMENT_LIBRARY)
        .renderListDataAsStream({
          FolderServerRelativeUrl: folderRelativeUrl,
          ViewXml: ViewXml,
          Paging: pagingInfo ? pagingInfo.replace("?", "") : null,
          RenderOptions: 2
        });

      batchCount++;

      // Process files from this batch
      if (result.Row && result.Row.length > 0) {
        for (const item of result.Row) {
          if (item.FSObjType === "0" && !processed.has(item.FileRef)) {
            // Calculate relative path within the zip
            const itemPath = item.FileDirRef.replace(folderRelativeUrl, "").replace(/^\//, "");
            const fullPath = itemPath ? `${currentPath}/${itemPath}` : currentPath;

            files.push({
              url: item.FileRef,
              name: item.FileLeafRef,
              path: fullPath
            });
            processed.add(item.FileRef);
          }
        }

        if (updateToastMessage && loaderToastBottomCenter) {
          updateToastMessage(
            "Scanning folder...",
            `Found ${files.length} files in ${folderName}... (Batch ${batchCount})`,
            loaderToastBottomCenter
          );
        }
      }

      // Check if there are more items - FIXED: properly check NextHref
      if (result.NextHref && result.NextHref.trim() !== "") {
        pagingInfo = result.NextHref;
        
        // Small delay to avoid throttling
        await new Promise(resolve => setTimeout(resolve, 100));
      } else {
        // No more pages, exit loop
        break;
      }
    }
  } catch (error) {
    console.error(`Error collecting files from folder ${folderName}:`, error);
    if (!cancelDownload) {
      throw error;
    }
  }

  return files;
};

// Split files into groups based on size and count limits
const splitIntoZipGroups = (files: any[]): any[][] => {
  const groups: any[][] = [];
  let currentGroup: any[] = [];
  let currentSize = 0;

  for (const file of files) {
    // Add to current group if under limits
    if (currentGroup.length >= MAX_FILES_PER_ZIP || currentSize >= MAX_ZIP_SIZE * 0.8) {
      if (currentGroup.length > 0) {
        groups.push(currentGroup);
      }
      currentGroup = [];
      currentSize = 0;
    }

    currentGroup.push(file);
  }

  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }

  return groups.length > 0 ? groups : [files];
};

// Create and download a zip file with progress tracking
const createAndDownloadZip = async (
  files: any[],
  zipIndex: number,
  totalZips: number,
  totalFiles: number,
  loaderToastBottomCenter: any,
  toastBottomCenter: any,
  updateToastMessage: any,
  siteRelativeUrl: string
) => {
  const zip = new JSZip();
  let processedCount = 0;

  try {
    // Process files in batches to avoid memory issues
    for (let i = 0; i < files.length; i += BATCH_SIZE) {
      if (cancelDownload) {
        throw new Error("Download cancelled");
      }

      const batch = files.slice(i, i + BATCH_SIZE);

      updateToastMessage(
        `Creating zip ${zipIndex + 1}/${totalZips}...`,
        `Processing files ${processedCount + 1}-${Math.min(processedCount + batch.length, files.length)} of ${files.length}...`,
        loaderToastBottomCenter
      );

      // Download files in parallel within batch
      const batchPromises = batch.map(async (file) => {
        try {
          const fileBlob = await sp.web.getFileByServerRelativeUrl(file.url).getBlob();
          const filePath = file.path ? `${file.path}/${file.name}` : file.name;
          zip.file(filePath, fileBlob);
        } catch (error) {
          console.error(`Failed to add ${file.name} to zip:`, error);
          // Continue with other files even if one fails
        }
      });

      await Promise.all(batchPromises);
      processedCount += batch.length;

      // Small delay between batches to prevent throttling
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    if (cancelDownload) {
      throw new Error("Download cancelled");
    }

    // Generate and download zip
    updateToastMessage(
      `Generating zip ${zipIndex + 1}/${totalZips}...`,
      "Compressing files, please wait...",
      loaderToastBottomCenter
    );

    const zipBlob = await zip.generateAsync(
      { type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } },
      (metadata) => {
        if (cancelDownload) {
          throw new Error("Download cancelled");
        }
        // Progress callback during zip generation
        const percent = metadata.percent.toFixed(0);
        updateToastMessage(
          `Generating zip ${zipIndex + 1}/${totalZips}...`,
          `Compression progress: ${percent}%`,
          loaderToastBottomCenter
        );
      }
    );

    const zipFileName = totalZips > 1 ? `Documents_Part${zipIndex + 1}.zip` : "Documents.zip";
    saveAs(zipBlob, zipFileName);

    // Clear zip from memory
    zip.remove(/.*/);
  } catch (error) {
    console.error(`Error creating zip ${zipIndex + 1}:`, error);
    throw error;
  }
};

// Updated addFolderToZip function (for backward compatibility)
export const addFolderToZipOptimized = async (
  zip: any,
  folderUrl: any,
  folderName: any,
  siteRelativeUrl: string,
  DOCUMENT_LIBRARY: string
) => {
  // Use the optimized collection method
  const files = await collectFolderFilesOptimized(
    folderUrl,
    folderName,
    siteRelativeUrl,
    DOCUMENT_LIBRARY,
    new Set<string>()
  );

  // Add files to zip in batches
  for (let i = 0; i < files.length; i += BATCH_SIZE) {
    if (cancelDownload) {
      throw new Error("Download cancelled");
    }

    const batch = files.slice(i, i + BATCH_SIZE);
    const batchPromises = batch.map(async (file) => {
      try {
        const fileBlob = await sp.web.getFileByServerRelativeUrl(file.url).getBlob();
        const filePath = file.path ? `${file.path}/${file.name}` : file.name;
        zip.file(filePath, fileBlob);
      } catch (error) {
        console.error(`Failed to add ${file.name}:`, error);
      }
    });
    await Promise.all(batchPromises);
    
    // Delay between batches
    if (i + BATCH_SIZE < files.length) {
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  }
};





// Add this to your DocumentLibrary component imports
import { downloadFilesOptimized, setCancelDownload } from './DownloadHelpers';

// In your DocumentLibrary component, update these functions:

// Add this helper function to update toast messages
const updateToastMessage = (summary: string, detail: string, ref: any) => {
  if (ref.current) {
    // Clear existing and show new
    ref.current.clear();
    ref.current.show({ 
      severity: 'info', 
      summary: summary, 
      detail: detail, 
      life: 3000, 
      sticky: true,
      content: (props) => (
        <section className="toast-message-container">
          <div className="toast-message-content">
            <p className="toast-message-summary">{summary}</p>
            <p className="toast-message-detail">{detail}</p>
            <div className="toast-progress-wrapper">
              <ProgressBar mode="indeterminate" className="toast-progress-bar" />
            </div>
            <button 
              className="toast-cancel-button"
              onClick={() => {
                setCancelDownload(true);
                hideToastMessage(ref);
              }}
              style={{
                marginTop: '8px',
                padding: '6px 12px',
                background: '#d13438',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '13px',
                fontWeight: '500'
              }}
            >
              Cancel Download
            </button>
          </div>
        </section>
      )
    });
  }
};

// Update the showToastMessage function to support cancel button
const showToastMessage = (label: string, detail: string, ref: any, severity: string, isSticky = false, showCancel = false) => {
  if (showCancel) {
    ref.current.show({ 
      severity: severity, 
      summary: label, 
      detail: detail, 
      life: 3000, 
      sticky: isSticky,
      content: (props) => (
        <section className="toast-message-container">
          <div className="toast-message-content">
            <p className="toast-message-summary">{label}</p>
            <p className="toast-message-detail">{detail}</p>
            <div className="toast-progress-wrapper">
              <ProgressBar mode="indeterminate" className="toast-progress-bar" />
            </div>
            <button 
              className="toast-cancel-button"
              onClick={() => {
                setCancelDownload(true);
                hideToastMessage(ref);
              }}
              style={{
                marginTop: '8px',
                padding: '6px 12px',
                background: '#d13438',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '13px',
                fontWeight: '500'
              }}
            >
              Cancel Download
            </button>
          </div>
        </section>
      )
    });
  } else {
    ref.current.show({ severity: severity, summary: label, detail: detail, life: 3000, sticky: isSticky});
  }
};

// Replace your downloadFiles function with this:
const downloadFiles = async () => {
  await downloadFilesOptimized(
    selection,
    setSelectedItems,
    loaderToastBottomCenter,
    toastBottomCenter,
    showToastMessage,
    hideToastMessage,
    updateToastMessage,
    siteRelativeUrl,
    DOCUMENT_LIBRARY
  );
};

// Optional: Add CSS for better toast styling
const toastStyles = `
.toast-message-container {
  min-width: 300px;
  max-width: 500px;
}

.toast-message-content {
  padding: 12px;
}

.toast-message-summary {
  font-weight: 600;
  font-size: 14px;
  margin: 0 0 6px 0;
  color: #323130;
}

.toast-message-detail {
  font-size: 13px;
  margin: 0 0 8px 0;
  color: #605e5c;
}

.toast-progress-wrapper {
  margin: 8px 0;
}

.toast-progress-bar {
  height: 4px;
}

.toast-cancel-button:hover {
  background: #a4262c !important;
}

.toast-cancel-button:active {
  background: #8a1f23 !important;
}
`;

// Add the styles to your component or global stylesheet
